---
title: "Parent-wise cross-validation to check the accuracy of predicting cross (co)-variances"
author: "Marnin Wolfe"
date: "2021-May-14"
output: 
  workflowr::wflow_html:
    toc: true
editor_options:
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = F, 
                      eval = FALSE, # <- NOTE THAT EVAL SET TO FALSE!
                      tidy='styler', tidy.opts=list(strict=FALSE,width.cutoff=100), highlight=TRUE)
```

# Previous step

4.  [Preprocess data files](04-PreprocessDataFiles.html): Prepare haplotype and dosage matrices, pedigree and BLUPs, genetic map *and* recombination frequency matrix, for use in predictions.

Also:

5.  [Extract and process PHG files](08-PHGfiles.html): Extract a VCF file from the PHG `*.db` file produced by Evan Long. Subsequently, prepare haplotype and dosage matrices, genetic map *and* recombination frequency matrix, for use in predictions.

# Automating cross-validation

In the manuscript, the cross-validation is documented many pages and scripts, [documented here](https://wolfemd.github.io/PredictOutbredCrossVar/).

For ongoing GS, I have a function `runCrossVal()` that manages all inputs and outputs easy to work with pre-computed accuracies.

Goal here is to make a function: `runParentWiseCrossVal()`, or at least make progress towards developing one.

*However*, for computational reasons, I imagine it might still be best to separate the task into a few functions.

My goal is to simplify and integrate into the pipeline used for NextGen Cassava. In the paper, used multi-trait Bayesian ridge-regression (MtBRR) to obtain marker effects, and also stored posterior matrices on disk to later compute posterior mean variances. This was computationally expensive and different from my standard univariate REML approach. I think MtBRR and PMV are probably the least biased way to go... but...

For the sake of testing a simple integration into the in-use pipeline, I want to try univariate REML to get the marker effects, which I'll subsequently use for the cross-validation.

Revised the functions in **`package:predCrossVar`** to increase the computational efficiency. Not yet included into the actual R package but instead sourced from `code/predCrossVar.R`. Additional speed increases were achieved by extra testing to optimize balance of `OMP_NUM_THREADS` setting (multi-core BLAS) and parallel processing of the  crosses-being-predicted. Improvements will benefit users predicting with REML / Bayesian-VPM, but probably worse for Bayesian-PMV.

# Set-up server computing env.

Use a a singularity image from the rocker project, as recommended by Qi Sun to get an OpenBLAS-linked R environment that packages can easily be installed on.

**This first chunk is one-time only and doesn't take long. Saves a 650Mb `*.sif` file to server's /workdir/**
```{bash, eval=F}
# copy the project data
cd /home/jj332_cas/marnin/;
cp -R implementGMSinCassava /home/$USER;
# the project directory can be in my networked folder for 2 reasons:
# 1) singularity will automatically recognize and be able to access it
# 2) My analyses not read/write intensive; don't break server rules/etiquette 
# set up a working directory on the remote machine
mkdir /workdir/$USER
cd /workdir/$USER/; 

# pull a singularity image and save in the file rocker.sif
# next time you use the rocker.sif file to start the container
singularity pull rocker.sif docker://rocker/tidyverse:latest;
```

For analysis, operate each R session within a singularity Linux shell within a screen shell.
```{bash set-up R environment, eval=F}
# 1) start a screen shell 
screen; # or screen -r if re-attaching...
# 2) start the singularity Linux shell inside that
#singularity shell /workdir/$USER/rocker.sif; 
singularity shell ~/rocker2.sif; 
# Project directory, so R will use as working dir.
cd /home/mw489/implementGMSinCassava/;
# 3) Start R
R
```

# Parent-wise cross-validation

Fully-tested `runParentWiseCrossVal()` and component functions are in the `code/parentWiseCrossVal.R` script. 

Below, source it and use it for a full cross-validation run. 

```{r install packages if needed}
# install.packages(c("RhpcBLASctl","here","rsample","sommer","psych","future.callr","furrr","lme4"))
# install.packages('future.callr')
```

```{r parent-wise CV inputs}
require(tidyverse); require(magrittr); 
# 5 threads per Rsession for matrix math (openblas)
RhpcBLASctl::blas_set_num_threads(5)

# SOURCE CORE FUNCTIONS
source(here::here("code","parentWiseCrossVal.R"))
source(here::here("code","predCrossVar.R"))

# PEDIGREE
ped<-read.table(here::here("output","verified_ped.txt"),
                header = T, stringsAsFactors = F) %>% 
  rename(GID=FullSampleName,
         damID=DamID,
         sireID=SireID) %>% 
  dplyr::select(GID,sireID,damID)
# Keep only families with _at least_ 2 offspring
ped %<>%
  semi_join(ped %>% count(sireID,damID) %>% filter(n>1) %>% ungroup())

# BLUPs
blups<-readRDS(file=here::here("data","blups_forCrossVal.rds")) %>% 
  dplyr::select(-varcomp)

# GENOMIC RELATIONSHIP MATRICES (GRMS)
grms<-list(A=readRDS(file=here::here("output","kinship_A_IITA_2021May13.rds")),
           D=readRDS(file=here::here("output",
                                     "kinship_domGenotypic_IITA_2021July5.rds")))
## using A+domGenotypic (instead of domClassic used previously)
## will achieve appropriate dom effects for predicting family mean TGV
## but resulting add effects WILL NOT represent allele sub. effects and thus
## predictions won't equal GEBV, allele sub. effects will be post-computed
## as alpha = a + d(q-p)

# DOSAGE MATRIX
dosages<-readRDS(file=here::here("data",
                                 "dosages_IITA_filtered_2021May13.rds"))

# RECOMBINATION FREQUENCY MATRIX
recombFreqMat<-readRDS(file=here::here("data",
                                       "recombFreqMat_1minus2c_2021May13.rds"))
# HAPLOTYPE MATRIX
## keep only haplos for parents-in-the-pedigree
## those which will be used in prediction, saves memory
haploMat<-readRDS(file=here::here("data","haps_IITA_filtered_2021May13.rds"))
parents<-union(ped$sireID,ped$damID) 
parenthaps<-sort(c(paste0(parents,"_HapA"),
                   paste0(parents,"_HapB")))
haploMat<-haploMat[parenthaps,colnames(recombFreqMat)]

# SELECTION INDEX WEIGHTS
## from IYR+IK
## note that not ALL predicted traits are on index
SIwts<-c(logFYLD=20,
         HI=10,
         DM=15,
         MCMDS=-10,
         logRTNO=12,
         logDYLD=20,
         logTOPYLD=15,
         PLTHT=10) 
```

## model=DirDom

Server 1: modelType="DirDom"

cbsulm17 - 112 cores, 512 GB RAM
```{r model DirDom - 5 full reps - parent-wise CV}
cvDirDom_5rep5fold<-runParentWiseCrossVal(nrepeats=5,nfolds=5,seed=84,
                                          modelType="DirDom",
                                          ncores=20,nBLASthreads=5,
                                          outName="output/cvDirDom_5rep5fold",
                                          ped=ped,
                                          blups=blups,
                                          dosages=dosages,
                                          haploMat=haploMat,
                                          grms=grms,
                                          recombFreqMat = recombFreqMat,
                                          selInd = TRUE, SIwts = SIwts)
saveRDS(cvDirDom_5rep5fold,here::here("output","cvDirDom_5rep5fold_predAccuracy.rds"))
# [1] "Marker-effects Computed. Took  2.3851 hrs"
# [1] "Predicting cross variances and covariances"
# Joining, by = c("Repeat", "Fold")
# [1] "Done predicting fam vars. Took 59.08 mins for 198 crosses"
# [1] "Done predicting fam vars. Took 18.63 mins for 198 crosses"
# [1] "Done predicting fam vars. Took 64.82 mins for 216 crosses"
# [1] "Done predicting fam vars. Took 20.41 mins for 216 crosses"
# [1] "Done predicting fam vars. Took 46.42 mins for 156 crosses"
# [1] "Done predicting fam vars. Took 14.94 mins for 156 crosses"
# [1] "Done predicting fam vars. Took 63.45 mins for 210 crosses"
# [1] "Done predicting fam vars. Took 19.8 mins for 210 crosses"
# [1] "Done predicting fam vars. Took 50.62 mins for 171 crosses"
# [1] "Done predicting fam vars. Took 16.26 mins for 171 crosses"
# [1] "Done predicting fam vars. Took 49.87 mins for 163 crosses"
# [1] "Done predicting fam vars. Took 16.2 mins for 163 crosses"
# [1] "Done predicting fam vars. Took 73.37 mins for 253 crosses"
# [1] "Done predicting fam vars. Took 23.59 mins for 253 crosses"
# [1] "Done predicting fam vars. Took 56.32 mins for 190 crosses"
# [1] "Done predicting fam vars. Took 18.44 mins for 190 crosses"
# [1] "Done predicting fam vars. Took 47.33 mins for 161 crosses"
# [1] "Done predicting fam vars. Took 15.79 mins for 161 crosses"
# [1] "Done predicting fam vars. Took 59.18 mins for 189 crosses"
# [1] "Done predicting fam vars. Took 18.67 mins for 189 crosses"
# [1] "Done predicting fam vars. Took 64.72 mins for 205 crosses"
# [1] "Done predicting fam vars. Took 21.17 mins for 205 crosses"
# [1] "Done predicting fam vars. Took 63.97 mins for 213 crosses"
# [1] "Done predicting fam vars. Took 20.04 mins for 213 crosses"
# [1] "Done predicting fam vars. Took 53.03 mins for 180 crosses"
# [1] "Done predicting fam vars. Took 17.28 mins for 180 crosses"
# [1] "Done predicting fam vars. Took 58.67 mins for 199 crosses"
# [1] "Done predicting fam vars. Took 19.03 mins for 199 crosses"
# ....

# estimate 20 more hours, complete on July 12 very early AM?

# [1] "Accuracies predicted. Took  34.37369 hrs total.Goodbye!"
# Warning message:
# In for (ii in 1L:length(res)) { : closing unused connection 3 (localhost)
# > saveRDS(cvDirDom_5rep5fold,here::here("output","cvDirDom_5rep5fold_predAccuracy.rds"))
```


## model=AD
Server 2: modelType="AD"

cbsulm29 - 104 cores, 512 GB RAM

```{r model AD - 5 full reps - parent-wise CV}
grmsAD<-list(A=readRDS(file=here::here("output","kinship_A_IITA_2021May13.rds")),
             D=readRDS(file=here::here("output",
                                       "kinship_D_IITA_2021May13.rds")))
rm(grms)
cvAD_5rep5fold<-runParentWiseCrossVal(nrepeats=5,nfolds=5,seed=84,
                                      modelType="AD",
                                      ncores=20,
                                      outName="output/cvAD_5rep5fold",
                                      ped=ped,
                                      blups=blups,
                                      dosages=dosages,
                                      haploMat=haploMat,
                                      grms=grmsAD,
                                      recombFreqMat = recombFreqMat,
                                      selInd = TRUE, SIwts = SIwts)
saveRDS(cvAD_5rep5fold,here::here("output","cvAD_5rep5fold_predAccuracy.rds"))
# [1] "Marker-effects Computed. Took  1.81086 hrs"
# [1] "Done predicting fam vars. Took 43.11 mins for 198 crosses"
# [1] "Done predicting fam vars. Took 47.04 mins for 216 crosses"
# .....
# [1] "Accuracies predicted. Took  19.68694 hrs total.\n Goodbye!"
# [1] "Accuracies predicted. Took  19.73242 hrs total.Goodbye!"
# > saveRDS(cvAD_5rep5fold,here::here("output","cvAD_5rep5fold_predAccuracy.rds"))
```


# Standard clone-wise cross-validation

The new "parent-wise" cross-validation scheme assesses the accuracy of predicting the means and variances of crosses. 

The "standard" cross-validation, used in all previous genomic selection analyses (_e.g._ [IITA_2020GS CV](https://wolfemd.github.io/IITA_2020GS/06-Results.html#cross-validation-accuracy), [NRCRI_2021GS CV](https://wolfemd.github.io/NRCRI_2021GS/05-Results.html#Prediction_accuracy), [TARI_2020GS CV](https://wolfemd.github.io/TARI_2020GS/05-Results.html#Prediction_accuracy)), assesses the accuracy predicting the individual performance (breeding value or TGV). 

**[NEW]**: Below, I upgrade the `runCrossVal()` function used previously for "standard" cross-validation. Include selection index (via `selInd=` and `SIwts=` arguments) and a `modelType="DirDom"` option.

```{bash R environment, eval=F}
# 1) start a screen shell 
screen; # or screen -r if re-attaching...
# 2) start the singularity Linux shell inside that
#singularity shell /workdir/$USER/rocker.sif; 
singularity shell ~/rocker2.sif; 
# Project directory, so R will use as working dir.
cd /home/mw489/implementGMSinCassava/;
# 3) Start R
R
```
```{r clone-wise CV inputs}
require(tidyverse); require(magrittr); 

# 5 threads per Rsession for matrix math (openblas)
RhpcBLASctl::blas_set_num_threads(5)

# SOURCE CORE FUNCTIONS
source(here::here("code","gmsFunctions"))
source(here::here("code","predCrossVar.R"))

# BLUPs
blups<-readRDS(file=here::here("data","blups_forCrossVal.rds")) %>% 
  dplyr::select(-varcomp) %>% 
  rename(TrainingData=blups) # for compatibility with downstream functions

# SELECTION INDEX WEIGHTS
## from IYR+IK
## note that not ALL predicted traits are on index
SIwts<-c(logFYLD=20,
         HI=10,
         DM=15,
         MCMDS=-10,
         logRTNO=12,
         logDYLD=20,
         logTOPYLD=15,
         PLTHT=10) 
```

## Add DirDom and SELIND to runCrossVal func

The new `runCrossVal()` function will:

- optionally compute selection index accuracy.
- internally handle looping over multiple traits, rather than the previous version that handled one trait only
  * If only 1 trait (for now) force user to still make input as single element list
  * b/c who really has only 1 trait....
- Add control of both ncores and nBLASthreads to match other functions in `gmsFunctions.R`, `parentWiseCrossVal.R` and `predCrossVar.R`.
- The fitModels() internal function now loops over traits in serial.
- `ncores=` now parallelizes over repeat-folds while traits are handled in serial by each parallel worker
- `nBLASthreads=` controls the number of additional cores each worker uses to speed matrix computations
- if requested by `selInd=TRUE` (and supplying `SIwts`) each worker computes and returns the selection index accuracy 

```{r debug settings}
# # runCrossVal() inputs
# modelType="DirDom"
# blups %<>% 
#   slice(1:2) %>% # for testing, just 2 traits
#   mutate(TrainingData=map(TrainingData, # and sample a small fraction of clones 
#                           ~sample_frac(.,size = 0.1,replace = F)))
# 
# 
# nrepeats=2; 
# nfolds=2
# gid="GID"
# seed<-910838019
# 
# ncores=2
# nBLASthreads=20
# selInd=TRUE
# SIwts<-SIwts[blups$Trait]
```
```{r develop a new runCrossVal function}
#' @param modelType string, A, AD representing model with Additive-only, Add. plus Dominance, respectively. **NEW**: modelType="DirDom" includes a genome-wide homozygosity effect as in Xiang et al. 2016, uses a different dominance GRM and will probably be a little slower.
#' @param grms list of GRMs where each element is named either A, D, or, AD. Matrices supplied must match required by A, AD and ADE models. For ADE grms=list(A=A,D=D)...
#' @param blups nested data.frame with list-column "TrainingData" containing BLUPs. Each element of "TrainingData" list, is data.frame with de-regressed BLUPs, BLUPs and weights (WT) for training and test. If byGroup==TRUE, a column with Group as the header uniquely classifying GIDs into genetic groups, is expected.
# runCrossVal<-function(blups,
#                       modelType,
#                       selInd,SIwts = NULL,
#                       grms,dosages=NULL,
#                       nrepeats,nfolds,
#                       ncores=1,nBLASthreads=NULL,
#                       gid="GID",seed=NULL,...){
# 
# # same train-test folds across traits
# gids<-blups %>% 
#   unnest(TrainingData) %>% 
#   distinct(!!sym(gid)) %>% 
#   .[[gid]]
# 
# 
# # whether or not user inputs a master seed
# # generate and store in output
# # seeds to make each replicate reproducible.
# if(!is.null(seed)){
#   set.seed(seed); 
#   seeds<-sample(1:1e6,replace = F,size = nrepeats) 
# } else { 
#   seeds-sample(1:1e6,replace = F,size = nrepeats) }
# 
# # Set-up replicated cross-validation folds
# # splitting by clone (if clone in training dataset, it can't be in testing)
# require(rsample)
# cvsamples<-tibble(repeats=1:nrepeats,
#        seeds=seeds,
#        splits=map(seeds,function(seeds,...){
#          set.seed(seeds);
#          cvfolds<-vfold_cv(tibble(GID=gids),v = nfolds)
#          return(cvfolds)})) %>% 
#   unnest(splits)
# 
# ## The fitModels() internal function
# ## Now runs _across_ traits and, if requested,
# ## computes the selection index accuracy 
# ## runCrossVal() now parallelizes over repeat-folds using ncores
# ## Traits are handled in serial by each parallel worker
# ## nBLASthreads controls the number of additional cores each worker
# ## uses to speed matrix computations
# ## Internal function
# ## fits prediction model and calcs. accuracy for each train-test split
# 
# fitModels<-function(splits,modelType,
#                     blups,selInd,SIwts,
#                     gid="GID",
#                     grms,dosages=NULL,
#                     nBLASthreads){
# 
# # internal testing of fitModels() inputs - one rep-fold
# # splits<-cvsamples$splits[[1]]
# # rm(splits)
#   
#   if(!is.null(nBLASthreads)) { RhpcBLASctl::blas_set_num_threads(nBLASthreads) }
#   # workers in plan(multisession) need this call internal to the function, it seems.
#   
# # subset kinship (and if modelType=="DirDom" also the dosages) matrices
# ### only lines with BLUPs for cross-validation
# A<-grms[["A"]][gids,gids]
# if(modelType %in% c("AD","DirDom")){ 
#   D<-grms[["D"]][gids,gids]  }
# if(modelType=="DirDom"){ dosages<-dosages[gids,] }
#             
# # Set-up training set
#   predictions<-blups %>%
#     mutate(modelOut=map(TrainingData,function(TrainingData,...){
#       #TrainingData<-blups$TrainingData[[1]]
#       
#       trainingdata<-TrainingData %>% 
#         dplyr::rename(GID=!!sym(gid)) %>%
#         filter(GID %in% training(splits)[[gid]],
#                GID %in% rownames(A))
#       
#       trainingdata[[paste0(gid,"a")]]<-factor(trainingdata[["GID"]],
#                                               levels=rownames(A))
#       if(modelType %in% c("AD")){
#         trainingdata[[paste0(gid,"d")]]<-trainingdata[[paste0(gid,"a")]] }
#       if(modelType %in% c("DirDom")){
#         trainingdata[[paste0(gid,"d_star")]]<-trainingdata[[paste0(gid,"a")]] }
#       
#       # Set-up random model statements
#       randFormula<-paste0("~vs(",gid,"a,Gu=A)")
#       if(modelType %in% c("AD")){
#         randFormula<-paste0(randFormula,"+vs(",gid,"d,Gu=D)") }
#       if(modelType=="DirDom"){
#         randFormula<-paste0(randFormula,"+vs(",gid,"d_star,Gu=D)")
#         f<-getPropHom(dosages)
#         trainingdata %<>% mutate(f=f[trainingdata$GID]) }
#       
#       # Fixed model statements
#       fixedFormula<-ifelse(modelType=="DirDom",
#                            "drgBLUP ~1+f","drgBLUP ~1")
#       # Fit genomic prediction model
#       require(sommer)
#       fit <- sommer::mmer(fixed = as.formula(fixedFormula),
#                           random = as.formula(randFormula),
#                           weights = WT,
#                           data=trainingdata,
#                           date.warning = F,
#                           getPEV = FALSE)
#       
#       print(paste0("GBLUP model complete - one trait"))
#       if(modelType=="DirDom"){
#         
#         # Backsolve SNP effects
#         # Compute allele sub effects
#         ## Every model has an additive random term
#         ga<-as.matrix(fit$U[[paste0("u:",gid,"a")]]$drgBLUP,ncol=1)
#         M<-centerDosage(dosages)
#         
#         # model DirDom is a different add-dom partition,
#         ### add effects are not allele sub effects and gblups are not GEBV
#         addsnpeff<-backsolveSNPeff(Z=M,g=ga)
#         ### dom effects are called d*, gd_star or domstar
#         ### because of the genome-wide homoz. term included in model
#         gd_star<-as.matrix(fit$U[[paste0("u:",gid,"d_star")]]$drgBLUP,ncol=1)
#         domdevMat_genotypic<-dose2domDevGenotypic(dosages)
#         domstar_snpeff<-backsolveSNPeff(Z=domdevMat_genotypic,g=gd_star)
#         ### b = the estimate (BLUE) for the genome-wide homoz. effect
#         b<-fit$Beta[fit$Beta$Effect=="f","Estimate"]
#         ### calc. domsnpeff including the genome-wide homoz. effect
#         ### divide the b effect up by number of SNPs and _subtract_ from domstar
#         domsnpeff<-domstar_snpeff-(b/length(domstar_snpeff))
#         
#         ### allele substitution effects using a+d(q-p) where d=d*-b/p
#         p<-getAF(dosages)
#         q<-1-p
#         allelesubsnpeff<-addsnpeff+(domsnpeff*(q-p))
#       }
#       
#  # Gather the GBLUPs
# if(modelType %in% c("A","AD")){
#   gblups<-tibble(GID=as.character(names(fit$U[[paste0("u:",gid,"a")]]$drgBLUP)),
#                  GEBV=as.numeric(fit$U[[paste0("u:",gid,"a")]]$drgBLUP)) }
# if(modelType=="AD"){
#   gblups %<>% # compute GEDD (genomic-estimated dominance deviation)
#     mutate(GEDD=as.numeric(fit$U[[paste0("u:",gid,"d")]]$drgBLUP),
#            # compute GETGV
#            GETGV=rowSums(.[,grepl("GE",colnames(.))])) }
# if(modelType=="DirDom"){
#                   # re-calc the GBLUP, GEdomval using dom. effects where d=d*-b/p
#   ge_domval<-domdevMat_genotypic%*%domsnpeff
#   # calc. the GEBV using allele sub. effects where alpha=a+d(p-q), and d=d*-b/p
#   gebv<-M%*%allelesubsnpeff
#   # Tidy tibble of GBLUPs
#   gblups<-tibble(GID=as.character(names(fit$U[[paste0("u:",gid,"a")]]$drgBLUP)),
#                  GEadd=as.numeric(fit$U[[paste0("u:",gid,"a")]]$drgBLUP),
#                  GEdom_star=as.numeric(fit$U[[paste0("u:",gid,"d_star")]]$drgBLUP)) %>%
#     left_join(tibble(GID=rownames(ge_domval),GEdomval=as.numeric(ge_domval))) %>%
#     left_join(tibble(GID=rownames(gebv),GEBV=as.numeric(gebv))) %>%
#     # GETGV from GEadd + GEdomval
#     mutate(GETGV=GEadd+GEdomval)
#   print(paste0("Backsolving SNP effects for DirDom model compete - one trait"))
# }
# 
#  # this is to remove conflicts with dplyr function select() downstream
# detach("package:sommer",unload = T); detach("package:MASS",unload = T)
# 
# # free up the memory footprint
# rm(fit)
#       
# # Calculate accuracy for each trait
# ## Convert predicted gblups to a long-format
# gblups %<>% 
#   select(GID,any_of(c("GEBV","GETGV"))) %>% 
#   pivot_longer(any_of(c("GEBV","GETGV")),
#                names_to = "predOf",
#                values_to = "GBLUP")
# 
# ## Grab the test set BLUPs as validation data
# validationData<-TrainingData %>% 
#   dplyr::rename(GID=!!sym(gid)) %>%
#   dplyr::select(GID,BLUP) %>% 
#   filter(GID %in% testing(splits)[[gid]])
# 
#   # Measure accuracy in test set
#   ## cor(GEBV,BLUP)
#   ## cor(GETGV,BLUP)
# accuracy<-gblups %>% 
#   left_join(validationData) %>% 
#   nest(predVSobs=c(GID,GBLUP,BLUP)) %>% 
#   mutate(Accuracy=map_dbl(predVSobs,~cor(.$GBLUP,.$BLUP, use = 'complete.obs')))
# return(accuracy)
# }))
#   print(paste0("Genomic predictions done for all traits in one repeat-fold"))
# 
# predictions %<>% 
#   select(-TrainingData) %>% 
#   unnest(modelOut)
# 
# if(selInd){
#   # calc. SELIND and SELIND accuracy
#   
#   gblups<-predictions %>% 
#     select(-Accuracy) %>% 
#     unnest(predVSobs) %>% 
#     select(-BLUP) %>% 
#     pivot_wider(values_from = "GBLUP",
#                 names_from = "Trait")
#    gblups %<>% 
#      mutate(GBLUP=as.numeric((gblups %>%
#                                  select(names(SIwts)) %>%
#                                  as.matrix(.))%*%SIwts)) %>% 
#      select(predOf,GID,GBLUP)
# 
#    validationData<-blups %>% 
#      unnest(TrainingData) %>% 
#      select(Trait,GID,BLUP) %>% 
#      pivot_wider(names_from = "Trait", values_from = "BLUP")
#    validationData %<>% 
#      mutate(BLUP=as.numeric((validationData %>%
#                                select(names(SIwts)) %>%
#                                as.matrix(.))%*%SIwts)) %>% 
#      select(GID,BLUP)
#    
#    predictions %<>%
#      bind_rows(gblups %>% 
#                  left_join(validationData) %>% 
#                  nest(predVSobs=c(GID,GBLUP,BLUP)) %>% 
#                  mutate(Trait="SELIND") %>% 
#                  relocate(Trait,.before = 1) %>% 
#                  mutate(Accuracy=map_dbl(predVSobs,~cor(.$GBLUP,.$BLUP, use = 'complete.obs')))) 
# }
# 
# predictions %<>% 
#      mutate(NcompleteTestPairs=map_dbl(predVSobs,~na.omit(.) %>% nrow(.)))
# 
# return(predictions) 
# 
# }
# require(furrr); plan(multisession, workers = ncores)
# options(future.globals.maxSize=+Inf); options(future.rng.onMisuse="ignore")
# # quick test
# #cvsamples %<>% slice(1:2)
# cvsamples %<>% 
#   mutate(accuracyEstOut=future_map(splits,
#                                    ~fitModels(splits=.,modelType=modelType,
#                                               blups=blups,
#                                               selInd=selInd,SIwts=SIwts,
#                                               gid=gid,grms=grms,dosages=dosages,
#                                               nBLASthreads=nBLASthreads)))
# plan(sequential)
# return(cvsamples) 
# }

```
```{r test run the new function}
# # test<-fitModels(splits,modelType,blups,selInd,SIwts,
# #                 gid,grms,dosages,nBLASthreads)
# test_dirdom<-runCrossVal(blups=blups,modelType="DirDom",
#                          selInd=TRUE,SIwts=SIwts,
#                          grms=grms,dosages=dosages,
#                          nrepeats=2,nfolds=2,
#                          ncores=4,nBLASthreads=20,
#                          gid="GID",seed=121212)
# test_dirdom %>% unnest(accuracyEstOut)
# 
# grms_ad<-list(A=readRDS(file=here::here("output","kinship_A_IITA_2021May13.rds")),
#               D=readRDS(file=here::here("output","kinship_D_IITA_2021May13.rds")))
# test_ad<-runCrossVal(blups=blups,modelType="AD",
#                      selInd=TRUE,SIwts=SIwts,
#                      grms=grms_ad,dosages=NULL,
#                      nrepeats=2,nfolds=2,
#                      ncores=4,nBLASthreads=20,
#                      gid="GID",seed=121212)
# test_ad %>% unnest(accuracyEstOut) %>% select(-splits,-predVSobs) %>% as.data.frame

```

## Full run of both models 5-reps x 5-folds

cbsulm - 112 cores, 512 GB RAM
```{r runCrossVal - model DirDom}
# GENOMIC RELATIONSHIP MATRICES (GRMS)
grms<-list(A=readRDS(file=here::here("output","kinship_A_IITA_2021May13.rds")),
           D=readRDS(file=here::here("output",
                                     "kinship_domGenotypic_IITA_2021July5.rds")))
## using A+domGenotypic (instead of domClassic used previously)
## will achieve appropriate dom effects for predicting family mean TGV
## but resulting add effects WILL NOT represent allele sub. effects and thus
## predictions won't equal GEBV, allele sub. effects will be post-computed
## as alpha = a + d(q-p)

# DOSAGE MATRIX
dosages<-readRDS(file=here::here("data",
                                 "dosages_IITA_filtered_2021May13.rds"))

stdcv_dirdom<-runCrossVal(blups=blups,modelType="DirDom",
                          selInd=TRUE,SIwts=SIwts,
                          grms=grms,dosages=dosages,
                          nrepeats=5,nfolds=5,
                          ncores=20,nBLASthreads=5,
                          gid="GID",seed=9108338019)
saveRDS(stdcv_dirdom,here::here("output","stdcv_DirDom_predAccuracy.rds"))

```

cbsulm - 112 cores, 512 GB RAM
```{r runCrossVal - model AD}
# GENOMIC RELATIONSHIP MATRICES (GRMS)
grms_ad<-list(A=readRDS(file=here::here("output","kinship_A_IITA_2021May13.rds")),
              D=readRDS(file=here::here("output","kinship_D_IITA_2021May13.rds")))
## achieves the classic TGV=BV+TGV partition
stdcv_ad<-runCrossVal(blups=blups,modelType="AD",
                          selInd=TRUE,SIwts=SIwts,
                          grms=grms,dosages=NULL,
                          nrepeats=5,nfolds=5,
                          ncores=20,nBLASthreads=5,
                          gid="GID",seed=9108338019)
saveRDS(stdcv_ad,here::here("output","stdcv_AD_predAccuracy.rds"))
```



# [TO DO] PHG parent-wise cross-validation

# Next step / Results

6. [Genomic predictions](06-GenomicPredictions.html): 
  - A. Standard genomic prediction of individual GEBV and GETGV for all selection candidates using all available data. 
  - B. Predict cross means and variances for genomic mate selection



See [Results](07-Results.html): Home for plots and summary tables.



